fmod DCA2MC-BANNER is
    pr LEXICAL .

    op banner : -> String .
    eq banner = 
        "\n\n\t\t A Tableau-based Approach to Model Checking Linear Temporal Properties\n" +
        "\t\t DCA2MC Version 0.1 (May 19 2023)\n" +
        "\t\t Copyright(c) 2023, JAIST\n" +
        "\t\t All rights reserved. \n" +
        "\n Commands:" + 
        "\n     initialize[_,_,_] \t initlizes with the module, the inital state, and the formula for model checking as inputs" +
        "\n     layerCheck __ \t generates states with a layer configuration __ (e.g., 2 2)" +
        "\n     lastCheck \t\t model checks for the final layer" +
        "\n     check __ \t\t generates states with a layer configuration __ and model checks for the final layer" +
        "\n     analyze \t\t shows the current state with some informatoin for debugging" +
        "\n     help \t\t shows the command instructions" +
        "\n     q \t\t\t exists the application\n\n" .
endfm

mod DCA2MC-IO is
    pr DCA2MC-GRAMMAR .
    pr DCA2MC-BANNER .
    pr STD-STREAM .
    pr META-LEVEL .
    pr DATABASE .

    vars Atts : AttributeSet .
    vars S S' OUT : String .
    vars RP? : ResultPair? .
    vars X@Class : Cid .
    vars O : Oid .

    sort State .

    --- state of the application
    op init     : -> State [ctor] .
    op wait     : -> State [ctor] .
    op print    : -> State [ctor] .
    op idle     : -> State [ctor] .
    op quit     : -> State [ctor] .
    op execComm : -> State [ctor] .

    --- attributes
    op db:_    : Database -> Attribute [ctor] .
    op state:_ : State    -> Attribute [ctor] .
    op input:_ : TermList -> Attribute [ctor] .

    rl [init] :
       < O : X@Class | state: init, Atts >
    => < O : X@Class | state: print, Atts >
        write(stdout, O, banner) .
    
    rl [wrote] :
        < O : X@Class | state: print, Atts > wrote(O, stdout)
    =>  < O : X@Class | state: idle, Atts > .

    rl [input] :
        < O : X@Class | state: idle, Atts >
     => < O : X@Class | state: wait, Atts >
        getLine(stdin, O, "DCA2MC> ") .

    crl [parseComm] :
        < O : X@Class | state: wait, input: empty, Atts >
        gotLine(O, stdin, S)
    =>  if RP? :: ResultPair then
            < O : X@Class | state: execComm, input: getTerm(RP?), Atts >
        else
            < O : X@Class | state: print, input: empty, Atts >
            write(stdout, O, "Cannot parse the command\n")
        fi
    if RP? := metaParse(DCA2MC-GRAMMAR, tokenize(S), '@Input@) .

    rl [quit] :
        < O : X@Class | state: execComm, input: 'q.@Command@, Atts >
    =>  < O : X@Class | state: quit, input: empty > .
    --- =>  < O : X@Class | state: quit, input: empty, Atts > .
endm