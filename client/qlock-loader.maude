load ../specs/qlock.maude
load ../full-maude-lite.maude
load ../database.maude

mod QLOCK-DB is
    pr QLOCK .
    pr DATABASE .

    --- op sf : -> State&Formulas .
    --- eq sf = { '`{_`} ['__ ['queue:_ ['p1.Pid ],'cnt:_ ['s_ ['0.Zero ]],'pc`[_`]:_ ['p1.Pid ,'ws.Loc ],'pc`[_`]:_ ['p2.Pid ,'fs.Loc ]]]: [{ ('_R_ ['False.FalseFormula ,'_\/_ ['~_ ['inWs1.Prop ],'_U_ ['True.TrueFormula ,'inCs1.Prop ]]]) | ('_U_ ['True.TrueFormula ,'inCs1.Prop ])}]} .

    var OCs : Soup{OComp} .
    vars T T1 T2 : Term .
    var Q : Queue{Pid} .
    var TS : TermSet .
    var N :  Nat .
    var I : Pid .
    var L : Loc .

    op errState : -> Config .

    op getQueue : Config -> Queue{Pid} .
    eq getQueue({(queue: Q) OCs}) = Q .
    op getLoc : Config Pid -> Loc .
    eq getLoc({(pc[I]: L) OCs}, I) = L .
    op getCnt : Config -> Nat .
    eq getCnt({(cnt: N) OCs}) = N .

    var SF : State&Formulas .
    var AF : AndFormulas .
    var NS : NodeSet .
    var Nd : Node .
    var Ct : Constant .

    sort Json .

    op empJson : -> Json .
    op testJson : -> Json .
    op _,_ : Json Json -> Json [comm assoc id: empJson prec 37] .
    op {_} : Json -> Json .
    op [_] : Json -> Json .
    op _:_ : String Json -> Json [prec 36] .

    op AFL2Json : AndFormulas -> Json .
    op AFL2Json* : AndFormulas -> Json .
    eq AFL2Json(AF) = [ AFL2Json*(AF) ] .
    eq AFL2Json*(([NS], AF)) = [ NS2Json(NS) ], AFL2Json*(AF) . --- andFLs
    eq AFL2Json*(emptyAF) = empJson .

    op NS2Json : NodeSet -> Json .
    eq NS2Json((Nd, NS)) = [ Node2Json(Nd) ], NS2Json(NS) . --- orFLs
    eq NS2Json(empty) = empJson .

    op Node2Json : Node -> Json .
    eq Node2Json({T | TS}) = Term2Json(T), Node2Json({TS}) . --- andFLs
    eq Node2Json({emptyTermSet}) = empJson .

    op Term2Json : Term -> Json .
    eq Term2Json(T) = Term2String(T) .

    --- convert formulas to SPIN formulas
    subsort String < Json .
    op Term2String : Term -> String .
    eq Term2String('_U_[T1, T2]) = "(" + Term2String(T1) + ") U (" + Term2String(T2) + ")" .
    eq Term2String('_R_['False.FalseFormula, T]) = "[] (" + Term2String(T) + ")" .
    eq Term2String('_\/_[T1, T2]) = "(" + Term2String(T1) + ") || (" + Term2String(T2) + ")" .
    eq Term2String('_/\_[T1, T2]) = "(" + Term2String(T1) + ") && (" + Term2String(T2) + ")" .
    eq Term2String('~_[T]) = "!(" + Term2String(T) + ")" .
    eq Term2String('True.TrueFormula) = "true" .
    eq Term2String('False.FalseFormula) = "false" .
    eq Term2String('inWs1.Prop) = "pc[0] == ws" .
    eq Term2String('inCs1.Prop) = "pc[0] == cs" .
    eq Term2String('inFs1.Prop) = "pc[0] == fs" .
endm

eof

set print attribute on .

red sf .
red getState(sf) .
red getAndFormulas(sf) .
red downTerm(getState(sf), errState) .
red getQueue(downTerm(getState(sf), errState)) .
red init .
red AFL2Json(getAndFormulas(sf)) .
red Term2String('_U_['True.TrueFormula, 'inCs1.Prop]) .
red Term2String('_R_['False.FalseFormula, '_\/_['~_['inWs1.Prop], '_U_['True.TrueFormula, 'inCs1.Prop]]]) .

eof

[
    [
        [
            "(true) U (pc[p1] == cs)", 
            "[] ((!(pc[p1] == ws)) \\/ ((true) U (pc[p1] == cs)))"
        ]
    ]
]